# Inditex Technical Test

## Description
This project is a technical test for Inditex. It's consist in an API-Rest to access a products prices according to some
parameters.
Some methodologies used in the projects are: 
- DDD
- Hexagonal Architecture
- API-First

You can have more info about the API-Rest [here](#how-to-runtest-the-project)

## Stack
 - **`IDE`**: IntelliJ IDEA
 - **`Java`**: 21
 - **`SpringBoot`**: 3.2.4
   - spring-boot-starter-web
   - spring-boot-starter-data-jpa
   - spring-boot-starter-test
   - spring-boot-starter-validation
  
 - #### Dependencies
   - **`lombok`**
   - **`mapstruct`**
   - **`h2 database`**
   - **`SpringDoc (SwaggerUI)`**
   - **`JaCoCo Report`**
   - **`hibernate-jpamodelgen`**
   - **`ArchUnit`**
   
- #### Generated Coded
  - [**`API-First`**](#API-First) with openapitools
  - [**`Mappers`**](#Mappers) with mapstruct and lombok
  - [**`Class boilerplate`**](#Class-boilerplate) with lombok
  - [**`MetaModel`**](#MetaModel) with hibernate-jpamodelgen

### API-First
With API-First we develop first the openapi yaml file and then we autogenerate the code from the openapi file.
with this approach we focus first in the development of a robust API, and then we focus in the development of the logic.
Some of the benefits of API-First are:
- **Development teams can work in parallel**: Different groups can work on all sides of an API simultaneously without 
wasting time or money by waiting for application updates. This allows developers to mock APIs and effectively test 
any relevant dependencies. This can lead to an increase in productivity and efficiency.
- **Improved developer experience**: API-First Design creates an API that is well-designed, well-documented, and 
consistent, which is essential to a positive developer experience (DX). A positive DX is much desired since developers
interact with APIs daily. Because of this, developers can use APIs to easily integrate into other programs, quickly 
troubleshoot issues, and even onboard other developers in less time.
- **Reduced risk of failure**: APIs have become integral to the operational landscape, interacting with everything from
marketing and sales to consumer-facing applications representing the brand. Losses in any area can be devastating.
With API-First Design, error risk is significantly reduced due to inherent reliability, stability, and consistency of
design and implementation.
### Mappers
Mapstruct make easy to generate any mappers to change for example from model to response object, and in conjunction
with lombok is easier because we just need to create an interface like:
```java
@Mapper(componentModel = "spring")
public interface PriceMapper {
    PriceResponse toResponse(Price price);
}
```
### Class boilerplate
Lombok is well-known dependency to autogenerated all the boilerplate code of classes, like getters, setters, 
constructors, etc. We just need to put the annotations of lombok in the class like:
```java
@Data
@RequiredArgsConstructor
@NoArgsConstructor(force = true)
public class Price {
   /*...*/
}
```
### MetaModel
The objective of the metamodel is to prevent the use of constant string to refer the domain model properties, instead of
that `hibernate-jpamodelgen` autogenerate a static class for each @Entity class that find in the project.

In this way, for example, if we work with Specification pattern we can have something like that
````java
Specification<Price> spec = (root, query, criteriaBuilder) -> {
            Predicate brandIdPredicate = criteriaBuilder.equal(root.get("brandId"), brandId);
            Predicate productIdPredicate = criteriaBuilder.equal(root.get("productId"), productId);

            Predicate dateLessOrEqualStartDatePredicate = criteriaBuilder.lessThanOrEqualTo(root.get("start_date"), date);
            Predicate dateGreaterOrEqualEndDatePredicate = criteriaBuilder.greaterThanOrEqualTo(root.get("end_date"), date);

            query.orderBy(criteriaBuilder.desc(root.get("priority")));
            return criteriaBuilder.and(brandIdPredicate, productIdPredicate, dateLessOrEqualStartDatePredicate, dateGreaterOrEqualEndDatePredicate );
        };
````
and if we change any property of the model we have the risk to not view the impact.

With the metamodel we don't need to know the name of any properties, we just need to use the generated class and use 
the constant variable.
If we change any property we will autogenerate a new metamodel and if we have any issue the IDE will inform us.

````java
Specification<Price> spec = (root, query, criteriaBuilder) -> {
            Predicate brandIdPredicate = criteriaBuilder.equal(root.get(Price_.BRAND_ID), brandId);
            Predicate productIdPredicate = criteriaBuilder.equal(root.get(Price_.PRODUCT_ID), productId);

            Predicate dateLessOrEqualStartDatePredicate = criteriaBuilder.lessThanOrEqualTo(root.get(Price_.START_DATE), date);
            Predicate dateGreaterOrEqualEndDatePredicate = criteriaBuilder.greaterThanOrEqualTo(root.get(Price_.END_DATE), date);

            query.orderBy(criteriaBuilder.desc(root.get(Price_.PRIORITY)));
            return criteriaBuilder.and(brandIdPredicate, productIdPredicate, dateLessOrEqualStartDatePredicate, dateGreaterOrEqualEndDatePredicate );
        };
````

## How to run/test the project

##### Run project
```shell
mvn spring-boot:run
```

##### Run tests
```shell
mvn test
```

##### Swagger-UI
>[http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)

##### Postman test
You can find a postman export with some tests over the /price endpoint. 
> [Postman tests](src/main/resources/static/postmanTests.postman_collection.json)